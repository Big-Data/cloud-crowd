Here's a brief run-through of the life cycle of a job. Your application posts a JSON job request to your CloudCrowd *central server*, specifying the name of an *action* to be performed, a list of *inputs* (often URLs), an optional *callback_url* to be pinged when the job is complete, and an optional *options* hash for action-specific configuration. The central server divides up your job into a number of *work units*, one for each input. (If your action has a @split@ method, it will further subdivide each input into multiple work units.) All work units are placed into a queue and farmed out to the active *worker daemons* to be processed in parallel. Your application may request the status of your job from the central server at any time, to see how its coming along. When all of the workers have finished all of the job's work units, the completed job, along with the merged output, is handed back to your application according to the *callback_url* specified in the initial request.

!http://jashkenas.s3.amazonaws.com/images/cloud_crowd/anatomy.png!
